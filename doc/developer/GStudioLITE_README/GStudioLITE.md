## GSTUDIO-LITE: OPTIMIZATION OF GSTUDIO USING BACKEND CACHING WITH REVALIDATION
The aim of the project was to use smart server side caching technologies to
improve the performance of GStudio instances from a client perspective,
while keeping the tradeoff between caching and dynamicity to a minimum.


We decided to go with filesystem based caching for our purposes. Memcached, although faster can't store a lot of resources. Filesystem based caching needs a path to be set where-in the cached resources are going to be stored. Since we are using the secondary memory we can cache in a lot of resources for a very long period of time. The sections below indicate how we configured Django into the filesystem caching mode.

### DJANGO CACHING ARGUMENTS
![FileSystem Based Caching](Capture1.jpg).

Each cache backend can be given additional arguments to control caching
behavior. These arguments are provided as additional keys in the CACHES
setting. Valid arguments are as follows:

* **TIMEOUT**: The default timeout, in seconds, to use for the cache.
This argument defaults to 300 seconds (5 minutes). You can set
TIMEOUT to None so that, by default, cache keys never expire. A
value of 0 causes keys to immediately expire (effectively don't cache).
* **OPTIONS**: Any options that should be passed to the cache backend.
The list of valid options will vary with each backend, and cache
backends backed by a third-party library will pass their options
directly to the underlying cache library.  
Cache backends that implement their own culling strategy (i.e., the
locmem, filesystem and database backends) will honor the following
options:
    * **MAX ENTRIES**: The maximum number of entries allowed in
the cache before old values are deleted. This argument defaults
to 300.
    * **CULL FREQUENCY**: The fraction of entries that are culled
when MAX ENTRIES is reached. The actual ratio is 1 / CULL FREQUENCY, so set CULL FREQUENCY to 2 to cull
half the entries when MAX ENTRIES is reached. This argument
should be an integer and defaults to 3.  
A value of 0 for CULL FREQUENCY means that the entire
cache will be dumped when MAX ENTRIES is reached. On
some backends (database in particular) this makes culling much
faster at the expense of more cache misses.  
Memcached backends pass the contents of OPTIONS as keyword
arguments to the client constructors, allowing for more advanced
control of client behavior. For example usage, see below.
*  **KEY PREFIX**: A string that will be automatically included
(prepended by default) to all cache keys used by the Django server.
* **VERSION**: The default version number for cache keys generated by
the Django server.
* **KEY FUNCTION**: A string containing a dotted path to a function
that defines how to compose a prefix, version and key into a final
cache key.

### MIDDLEWARE
![Middleware](Capture2.jpg).

* **CACHE MIDDLEWARE ALIAS** : The cache alias to use for storage.
* **CACHE MIDDLEWARE SECONDS** : The number of seconds each page
should be cached.
* **CACHE MIDDLEWARE KEY PREFIX** : If the cache is shared across
multiple sites using the same Django installation, set this to the name of
the site, or some other string that is unique to this Django instance, to
prevent key collisions. Use an empty string if you dont care.
* **FetchFromCacheMiddleware** caches GET and HEAD responses with status
200, where the request and response headers allow. Responses to requests
for the same URL with different query parameters are considered to be
unique pages and are cached separately. This middleware expects that a
HEAD request is answered with the same response headers as the
corresponding GET request; in which case it can return a cached GET
response for HEAD request.
* Additionally, **UpdateCacheMiddleware** automatically sets a few headers in
each HttpResponse:
    * Sets the Expires header to the current date/time plus the defined
**CACHE MIDDLEWARE SECONDS**.
    * Sets the Cache-Control header to give a max age for the page again,
from the **CACHE MIDDLEWARE SECONDS** setting.
* If a view sets its own cache expiry time (i.e. it has a max-age section in its
Cache-Control header) then the page will be cached until the expiry time,
rather than **CACHE MIDDLEWARE SECONDS**. Using the decorators in
django.views.decorators.cache you can easily set a views expiry time (using
the cache control() decorator) or disable caching for a view (using the
never cache() decorator)

### FULL-SITE CACHING
We were asked to develop a mechanism that would cache the entire site at user discretion. Hence we developed a crawler-script in Python that uses Beuatiful Soup and Selenium to crawl through all the pages on any web-site. As the requests are being made, the responses to them will be cached continuously in the Filesystem Backend. They will remain as such, until any update is made in any of the pages. In that case, a fresh response will be served and replace the stale response from the cache.

### BEAUTIFUL SOUP LIBRARY
Beautiful Soup is a Python library for pulling data out of HTML and XML
files. It works with your favorite parser to provide idiomatic ways of
navigating, searching, and modifying the parse tree. It commonly saves
programmers hours or days of work. Beautiful Soup supports the HTML
parser included in Python's standard library, but it also supports a number
of third-party Python parsers.

* To parse a document, pass it into the BeautifulSoup constructor:
**soup=BeautifulSoup(content,"html.parser")**
* **find_all()** method of the soup object helps us find something like all
the "a" tags, or anything more complicated than the first tag with a
certain name.
* We can use the **get()** method as follows: tag.get('attr'), in order to
get the value of the specified attribute in a particular tag.
* **prettify()** method of the soup object converts the response object into
a string.

### SELENIUM
WebDriver in Selenium is a tool for automating web application testing,
and in particular to verify that they work as expected. WebDriver is the
name of the key interface against which tests should be written, but there
are several implementations. One such implementation is the Firefox
driver, which controls the Firefox browser using a Firefox plugin.

* The **get** method in the WebDriver API is used to navigate to the webpage
whose URL is specified as an argument to the function.
* The **page_source** object in the WebDriver API is used to render the content
of the webpage opened by the WebDriver entirely as HTML.

### CACHE REVALIDATION

We set in place a HTTP cache revalidation mechanism, to revalidate our cache entries on each access so as to avoid sending old responses in case the pages in relevance have been updated since the cache was last updated. We used cache_control headers for that (refer the below section for documentation). cache_control headers ask the cache to revalidate it's entries by comparing timestamps of the cache entries and timestamps of records in the back-end Database. The following flowchart describes the mechanism.

![Cache Revalidation](Capture5.jpg)

### CACHE CONTROL DECORATOR
The following decorator in django.views.decorators.cache controls server
and client-side caching.

![cache_control](Capture3.jpg)

![patch_cache_control](Capture4.jpg).
