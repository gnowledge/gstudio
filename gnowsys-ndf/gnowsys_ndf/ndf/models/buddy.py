from base_imports import *
from models_utils import ActiveUsers
from history_manager import *
from author import *

@connection.register
class Buddy(DjangoDocument):
    """
    Enables logged in user to add buddy.
    """

    collection_name = 'Buddies'

    structure = {
        '_type': unicode,
        'loggedin_userid': int,
        'session_key': basestring,
        'buddy_in_out': dict,
            # e.g:
            # buddy_in_out = {
            #           "auth_id": [
            #                         {"in": datetime.datetime, "out": datetime.datetime},
            #                         {"in": datetime.datetime, "out": datetime.datetime}
            #                    ]
            #           }
        'starts_at': datetime.datetime,
        'ends_at': datetime.datetime
    }

    required_fields = ['loggedin_userid', 'session_key']

    use_dot_notation = True

    @staticmethod
    def query_buddy_obj(loggedin_userid, session_key):
        '''
        query to get buddy object from following parameters:
            - loggedin_userid: django User ID.
            - session_key: unique session key generated by django session middleware.
        '''
        return buddy_collection.one({
                                        'loggedin_userid': int(loggedin_userid),
                                        'session_key': str(session_key)
                                    })


    def get_filled_buddy_obj(self,
                            loggedin_userid,
                            session_key,
                            buddy_in_out={},
                            starts_at=datetime.datetime.now(),
                            ends_at=None):

        self['loggedin_userid']= loggedin_userid
        self['session_key']    = session_key
        self['buddy_in_out']   = buddy_in_out
        self['starts_at']      = starts_at
        self['ends_at']        = ends_at

        return self


    @staticmethod
    def is_buddy_active(single_buddy_in_out_list):
        '''
        returns True or False 'bool' type value.

            - True : If buddy is active
                    (i.e: holding active session dict having {'out': None})

            - False: If buddy is not active
                    (i.e: holding active session dict having {'out': datetime.datetime})
        '''
        return (not bool(Buddy.get_latest_in_out_dict(single_buddy_in_out_list)['out']))


    @staticmethod
    def get_latest_in_out_dict(single_buddy_in_out_list):
        '''
        Returns last in out dict of buddy (if it exists)
        else returns empty structured dict.
        '''
        if len(single_buddy_in_out_list) > 0:
            return single_buddy_in_out_list[-1:][0]
        else:
            return { 'in': None, 'out': None }


    def get_active_authid_list_from_single_buddy(self):

        active_buddy_auth_list = []

        for auth_oid, in_out_list in self.buddy_in_out.iteritems():
            # if len(in_out_list) > 0:
            #     if not in_out_list[-1:][0]['out']:
                    # active_buddy_auth_list.append(auth_oid)
            if self.is_buddy_active(in_out_list):
                active_buddy_auth_list.append(auth_oid)

        # print "active_buddy_auth_list", active_buddy_auth_list
        return active_buddy_auth_list


    def add_buddy(self):
        pass


    def remove_buddy(self, buddy_authid):
        '''
        Removing/Relesing single buddy.
        and returning modified self object (without doing DB .save() operation).
        '''

        # only active buddies will be released
        if self.is_buddy_active(self.buddy_in_out[buddy_authid]):

            # this means buddy is successfully joined and not released.
            # now we need to release this buddy by adding datetime.datetime to 'out'
            self.get_latest_in_out_dict(self.buddy_in_out[buddy_authid])['out'] = datetime.datetime.now()

            return self


    def remove_all_buddies(self):
        '''
        - Removes/releses all existing-active buddies in single buddy object.
        - it doesn't close buddy session/object.
        - i.e: It don't add datetime.datetime.now() to 'ends_at' field.
        - without doing DB .save() operation.
        '''
        active_buddy_authid_list = self.get_active_authid_list_from_single_buddy()

        for each_buddy_authid in active_buddy_authid_list:
            print "- Released Buddy: ", Node.get_name_id_from_type(each_buddy_authid, u'Author')[0]
            self.get_latest_in_out_dict(self.buddy_in_out[each_buddy_authid])['out'] = datetime.datetime.now()

        return self


    def end_buddy_session(self):
        '''
        terminates the buddy session:
            - removes all buddies.
            - It add datetime.datetime.now() to 'ends_at' field.
            - buddy object will be saved using .save() method.
        '''

        if not self.ends_at:
            self = self.remove_all_buddies()
            self.ends_at = datetime.datetime.now()
            self.save()

        # active_buddy_authid_list = self.get_active_authid_list_from_single_buddy()
        # active_buddy_userids_list = Author.get_user_id_list_from_author_oid_list(active_buddy_authid_list)
        # DjangoActiveUsersGroup.update_user_set(remove=active_buddy_userids_list)

        return self


    @staticmethod
    def get_added_and_removed_buddies_dict(existing_userids_list, updated_userids_list):

        # Example Set Operations:
        #
        # existing = {1, 2, 3}
        # updated  = {3, 4, 5}
        #
        # updated - existing
        # {4, 5}
        # ------- indicates added user's w.r.t updated
        #
        # existing - updated
        # {1, 2}
        # ------- indicates removed users w.r.t updated

        result_dict = {'added': [], 'removed': []}

        result_dict['added'] = list(set(updated_userids_list) - set(existing_userids_list))

        result_dict['removed'] = list(set(existing_userids_list) - set(updated_userids_list))

        return result_dict


    @staticmethod
    def get_active_buddies_user_ids_list():

        active_users = ActiveUsers.get_active_id_session_keys()
        active_users_session_keys = active_users.values()
        active_user_ids = active_users.keys()

        Buddy.close_incomplete_buddies(active_users)
        active_buddies = buddy_collection.find({
                                    'session_key': {'$in': active_users_session_keys},
                                    'ends_at': None
                                })

        active_buddy_auth_list = []
        active_buddy_userids_list = active_user_ids

        for each_buddy in active_buddies:
            active_buddy_auth_list += each_buddy.get_active_authid_list_from_single_buddy()
            active_buddy_userids_list.append(each_buddy['loggedin_userid'])

        active_buddy_userids_list += Author.get_user_id_list_from_author_oid_list(active_buddy_auth_list)
        active_buddy_userids_list = list(set(active_buddy_userids_list))

        return active_buddy_userids_list


    @staticmethod
    def close_incomplete_buddies(active_users=None):

        if not active_users:
            active_users = ActiveUsers.get_active_id_session_keys()

        active_users_session_keys = active_users.values()
        incomplete_buddies = buddy_collection.find({
                                    'session_key': {'$nin': active_users_session_keys},
                                    'ends_at': None
                                })

        for each_incomplete_buddy in incomplete_buddies:
            each_incomplete_buddy.end_buddy_session()


    @staticmethod
    def update_buddies(loggedin_userid, session_key, buddy_auth_ids_list=[]):
        buddy_obj = buddy_collection.one({
                    'session_key': str(session_key),
                    'loggedin_userid': int(loggedin_userid)
                })

        if not buddy_obj:
            # it's a new buddy-session. So create a new buddy instance.
            buddy_obj = buddy_collection.collection.Buddy()
            buddy_obj = buddy_obj.get_filled_buddy_obj(loggedin_userid, session_key)

        current_active_buddy_auth_list = buddy_obj.get_active_authid_list_from_single_buddy()

        if set(current_active_buddy_auth_list) == set(buddy_auth_ids_list):
            return current_active_buddy_auth_list

        new_in_dict = { 'in': datetime.datetime.now(), 'out': None }
        existing_buddy_in_out_auth_list  = buddy_obj.buddy_in_out.keys()

        # list of all buddies auth ids:
        all_buddies = list(set(existing_buddy_in_out_auth_list + buddy_auth_ids_list))

        for each_buddy in all_buddies:
            # each_buddy is author _id

            if each_buddy in buddy_auth_ids_list:
                if each_buddy in existing_buddy_in_out_auth_list:
                    # this means, user was/is already buddy and already contains some entries/dicts.
                    # in this we must ensure that last dict's out is None.

                    if not Buddy.is_buddy_active(buddy_obj.buddy_in_out[each_buddy]):
                        # this means buddy is successfully joined and released.
                        # now buddy is getting in again. so make new dict and append.
                        buddy_obj.buddy_in_out[each_buddy].append(new_in_dict)

                else:
                    buddy_obj.buddy_in_out[each_buddy] = [new_in_dict]

            else:
                # this means, user was/is already buddy and already contains some entries/dicts.
                if each_buddy in existing_buddy_in_out_auth_list:

                    buddy_obj.remove_buddy(each_buddy)

        active_buddy_auth_list = buddy_obj.get_active_authid_list_from_single_buddy()

        buddy_obj.ends_at = None if active_buddy_auth_list else datetime.datetime.now()

        if current_active_buddy_auth_list != active_buddy_auth_list:
            buddy_obj.save()

            added_removed_buddies_dict = Buddy.get_added_and_removed_buddies_dict(
                                                        current_active_buddy_auth_list,
                                                        active_buddy_auth_list
                                                        )


            added_buddies_userids_list = Author.get_user_id_list_from_author_oid_list(added_removed_buddies_dict['added'])
            # print "added_buddies_userids_list : ", added_buddies_userids_list
            removed_buddies_userids_list = Author.get_user_id_list_from_author_oid_list(added_removed_buddies_dict['removed'])
            # print "removed_buddies_userids_list : ", removed_buddies_userids_list

            # DjangoActiveUsersGroup.update_user_set(
            #                                     add=added_buddies_userids_list,
            #                                     remove=removed_buddies_userids_list
            #                                     )

        else:
            buddy_obj = None

        return active_buddy_auth_list


    def get_all_buddies_auth_ids(self):
        return self['buddy_in_out'].keys()

    def get_all_buddies_user_ids(self):
        return Author.get_user_id_list_from_author_oid_list(self['buddy_in_out'].keys())

    @staticmethod
    def get_buddy_cur_from_userid_datetime(user_id, datetime_obj):
        return buddy_collection.find({
                                    'loggedin_userid': user_id,
                                    'starts_at': {'$lte': datetime_obj},
                                    '$or': [
                                            {'ends_at': {'$gte': datetime_obj}},
                                            {'ends_at': None}
                                        ]
                                })

    @staticmethod
    def get_buddy_userids_list_within_datetime(user_id, datetime_obj):
        buddy_cur = Buddy.get_buddy_cur_from_userid_datetime(user_id, datetime_obj)
        all_buddies_authid_list = []
        for each_buddy_obj in buddy_cur:
            # all_buddies_authid_list += each_buddy_obj.get_all_buddies_auth_ids()
            for each_buddy_authid, in_out_time in each_buddy_obj.buddy_in_out.iteritems():
                for each_io in in_out_time:
                    if (not each_io['out'] and datetime_obj > each_io['in']) \
                    or (each_io['out'] and datetime_obj < each_io['out'] and datetime_obj > each_io['in']):
                        all_buddies_authid_list.append(each_buddy_authid)

        if not all_buddies_authid_list:
            return []

        else:
            return Author.get_user_id_list_from_author_oid_list(set(dict.fromkeys(all_buddies_authid_list).keys()))


    # method for sitewide buddies:

    @staticmethod
    def sitewide_all_buddies():
        return buddy_collection.find()

    @staticmethod
    def sitewide_all_active_buddies():
        return buddy_collection.find({'ends_at': None})

    @staticmethod
    def sitewide_remove_all_buddies():
        sitewide_all_active_buddies = Buddy.sitewide_all_active_buddies()
        print "\nFound %d buddy/buddies container object(s)\n"%sitewide_all_active_buddies.count()

        for each_buddy in sitewide_all_active_buddies:
            each_buddy.end_buddy_session()

        return sitewide_all_active_buddies

    # --- END OF methods for sitewide buddies


    def save(self, *args, **kwargs):

        is_new = False if ('_id' in self) else True

        super(Buddy, self).save(*args, **kwargs)

        # storing Filehive JSON in RSC system:
        history_manager = HistoryManager()
        rcs_obj = RCS()

        if is_new:

            # Create history-version-file
            if history_manager.create_or_replace_json_file(self):
                fp = history_manager.get_file_path(self)
                message = "This document of Buddy (having session_key: " + str(self.session_key) + " and user id: " + str(self.loggedin_userid) + " ) is created on " + str(datetime.datetime.now())
                rcs_obj.checkin(fp, 1, message.encode('utf-8'), "-i")

        else:
            # Update history-version-file
            fp = history_manager.get_file_path(self)

            try:
                rcs_obj.checkout(fp, otherflags="-f")

            except Exception as err:
                try:
                    if history_manager.create_or_replace_json_file(self):
                        fp = history_manager.get_file_path(self)
                        message = "This document of Buddy (having session_key: " + str(self.session_key) + " and user id: " + str(self.loggedin_userid) + " ) is re-created on " + str(datetime.datetime.now())
                        rcs_obj.checkin(fp, 1, message.encode('utf-8'), "-i")

                except Exception as err:
                    print "\n DocumentError: This document (", self._id, ":", str(self.session_key), ") can't be re-created!!!\n"
                    node_collection.collection.remove({'_id': self._id})
                    raise RuntimeError(err)

            try:
                if history_manager.create_or_replace_json_file(self):
                    message = "This document of Buddy (having session_key: " + str(self.session_key) + " and user id: " + str(self.loggedin_userid) + " ) is lastly updated on " + str(datetime.datetime.now())
                    rcs_obj.checkin(fp, 1, message.encode('utf-8'))

            except Exception as err:
                print "\n DocumentError: This document (", self._id, ":", str(self.session_key), ") can't be updated!!!\n"
                raise RuntimeError(err)

buddy_collection    = db["Buddies"].Buddy
